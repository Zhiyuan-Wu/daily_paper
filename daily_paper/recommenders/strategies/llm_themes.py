"""
LLM-generated interest theme recommender.

This strategy uses LLM to generate interest themes from the user's recently
marked papers, then recommends papers matching those themes.
"""

from __future__ import annotations

import json
import logging
from datetime import datetime, timedelta
from typing import List

from daily_paper.config import Config
from daily_paper.database import InterestTheme, Paper, PaperInteraction
from daily_paper.embeddings.client import EmbeddingClient
from daily_paper.embeddings.utils import cosine_similarity
from daily_paper.recommenders.base import BaseRecommender, RecommendationResult
from daily_paper.summarizers.llm_client import LLMClient

logger = logging.getLogger(__name__)


class LLMThemeRecommender(BaseRecommender):
    """
    Recommend papers based on LLM-generated interest themes.

    This strategy:
    1. Checks for active themes in InterestTheme table
    2. Generates new themes if:
       - No active themes exist, OR
       - Last theme generation was > theme_refresh_days ago, OR
       - User has marked >= theme_refresh_papers new interested papers since last generation
    3. Recommends papers semantically similar to active themes

    Themes are generated by analyzing the user's recently interested papers
    and extracting key research areas/topics.

    Typical usage:
        >>> recommender = LLMThemeRecommender(session, config, embedding_client, llm_client)
        >>> results = recommender.recommend(candidate_papers, top_k=10)

    Attributes:
        session: Database session.
        config: Application configuration.
        embedding_client: Embedding service client.
        llm_client: LLM service client for theme generation.
    """

    def __init__(
        self,
        session,
        config: Config = None,
        embedding_client: EmbeddingClient = None,
        llm_client: LLMClient = None,
    ):
        """
        Initialize the LLM theme recommender.

        Args:
            session: SQLAlchemy database session.
            config: Application configuration.
            embedding_client: Embedding service client.
            llm_client: LLM service client.
        """
        super().__init__(session, config)
        self.config = config or Config.from_env()
        self.embedding_client = embedding_client or EmbeddingClient(self.config.embedding)
        self.llm_client = llm_client or LLMClient(self.config.llm)

    @property
    def strategy_name(self) -> str:
        """Return strategy identifier."""
        return "llm_themes"

    def recommend(
        self,
        candidate_papers: List[Paper],
        top_k: int = 10,
        **kwargs,
    ) -> List[RecommendationResult]:
        """
        Generate recommendations based on LLM-generated interest themes.

        Args:
            candidate_papers: List of papers to consider.
            top_k: Maximum number of recommendations to return.
            **kwargs: Additional parameters (force_regenerate, min_similarity).

        Returns:
            List of RecommendationResult sorted by theme similarity descending.

        Implementation details:
            - Checks for active themes, generates if needed
            - Calculates semantic similarity between papers and themes
            - Returns top-K papers most similar to active themes
        """
        # Get configuration
        theme_refresh_days = getattr(self.config.recommendation, 'theme_refresh_days', 30)
        theme_refresh_papers = getattr(self.config.recommendation, 'theme_refresh_papers', 20)
        min_similarity = kwargs.get("min_similarity", self.config.recommendation.min_similarity)
        force_regenerate = kwargs.get("force_regenerate", False)

        # Check if we need to generate themes
        active_themes = (
            self.session.query(InterestTheme)
            .filter(InterestTheme.is_active == True)
            .all()
        )

        need_regeneration = force_regenerate or self._should_regenerate_themes(
            active_themes, theme_refresh_days, theme_refresh_papers
        )

        if need_regeneration:
            logger.info("Generating new interest themes")
            active_themes = self._generate_themes()

        if not active_themes:
            logger.warning("No active themes available for recommendation")
            return []

        logger.info(f"LLM themes: Using {len(active_themes)} active themes")

        # Filter out read papers
        papers = self._filter_read_papers(candidate_papers)
        if not papers:
            logger.warning("No papers after filtering read papers")
            return []

        # Generate embeddings for themes
        try:
            theme_texts = [theme.theme for theme in active_themes]
            theme_embeddings = self.embedding_client.get_embeddings(theme_texts)

            # Generate embeddings for candidate papers
            paper_texts = []
            for paper in papers:
                text_parts = []
                if paper.title:
                    text_parts.append(paper.title)
                if paper.abstract:
                    text_parts.append(paper.abstract)
                paper_texts.append(" ".join(text_parts) if text_parts else "No content")

            paper_embeddings = self.embedding_client.get_embeddings(paper_texts)

        except Exception as e:
            logger.error(f"Failed to generate embeddings for LLM themes: {e}")
            return []

        # Calculate maximum similarity to any theme for each paper
        results = []
        for idx, paper_emb in enumerate(paper_embeddings):
            # Find maximum similarity to any theme
            max_sim = 0.0
            best_theme = None

            for theme_idx, theme_emb in enumerate(theme_embeddings):
                sim = cosine_similarity(paper_emb, theme_emb)
                if sim > max_sim:
                    max_sim = sim
                    best_theme = active_themes[theme_idx]

            if max_sim >= min_similarity:
                results.append(
                    RecommendationResult(
                        paper_id=papers[idx].id,
                        score=float(max_sim),
                        reason=f"Matches theme: '{best_theme.theme}' (similarity: {max_sim:.3f})",
                        strategy_name=self.strategy_name,
                    )
                )

        # Sort by score and return top-K
        results.sort(key=lambda r: r.score, reverse=True)
        logger.info(
            f"LLM themes: Generated {len(results)} recommendations "
            f"(min_similarity={min_similarity:.2f})"
        )

        return results[:top_k]

    def _should_regenerate_themes(
        self,
        active_themes: List[InterestTheme],
        refresh_days: int,
        refresh_papers: int,
    ) -> bool:
        """
        Check if themes should be regenerated.

        Args:
            active_themes: Currently active themes.
            refresh_days: Regenerate if older than this (days).
            refresh_papers: Regenerate if this many new interested papers.

        Returns:
            True if themes should be regenerated, False otherwise.
        """
        # No active themes
        if not active_themes:
            return True

        # Get most recent theme by created_at
        latest_theme = max(active_themes, key=lambda t: t.created_at or datetime.min)
        days_since_last = (datetime.now() - latest_theme.created_at).days if latest_theme.created_at else 999

        # Check if themes are too old
        if days_since_last > refresh_days:
            logger.info(f"Themes are {days_since_last} days old, regenerating")
            return True

        # Check if enough new interested papers since last theme generation
        # Get papers interested since the last theme was created
        if latest_theme.created_at:
            interested_count = (
                self.session.query(PaperInteraction)
                .filter(
                    PaperInteraction.action == "interested",
                    PaperInteraction.created_at >= latest_theme.created_at,
                )
                .count()
            )
        else:
            interested_count = 0

        if interested_count >= refresh_papers:
            logger.info(f"Found {interested_count} new interested papers since last theme, regenerating")
            return True

        return False

    def _generate_themes(self) -> List[InterestTheme]:
        """
        Generate new interest themes using LLM.

        Returns:
            List of newly created InterestTheme objects.

        Implementation:
            1. Deactivates old themes
            2. Fetches recent interested papers
            3. Uses LLM to extract 5-10 key interest themes
            4. Saves new themes to database
        """
        # Deactivate old themes
        self.session.query(InterestTheme).filter(InterestTheme.is_active == True).update(
            {"is_active": False}
        )
        self.session.commit()

        # Get recently interested papers (last 60 days)
        cutoff_date = datetime.now() - timedelta(days=60)
        interested_interactions = (
            self.session.query(PaperInteraction)
            .filter(
                PaperInteraction.action == "interested",
                PaperInteraction.created_at >= cutoff_date,
            )
            .limit(30)  # Limit to 30 most recent
            .all()
        )

        if not interested_interactions:
            logger.warning("No interested papers for theme generation")
            return []

        interested_paper_ids = [i.paper_id for i in interested_interactions]
        interested_papers = (
            self.session.query(Paper)
            .filter(Paper.id.in_(interested_paper_ids))
            .all()
        )

        # Prepare paper summaries for LLM
        paper_summaries = []
        for i, paper in enumerate(interested_papers, 1):
            summary = f"{i}. Title: {paper.title or 'N/A'}\n"
            if paper.abstract:
                summary += f"   Abstract: {paper.abstract[:500]}...\n"
            paper_summaries.append(summary)

        papers_text = "\n\n".join(paper_summaries)

        # Generate themes using LLM
        system_prompt = """You are a research advisor analyzing a user's reading preferences.
Extract 5-10 key interest themes from the list of papers the user has marked as interested.

Each theme should:
- Be a concise phrase (2-6 words)
- Represent a specific research area or topic
- Be specific enough to distinguish from other themes

Return ONLY a JSON array of theme strings, no additional text.
Example format: ["Theme 1", "Theme 2", "Theme 3"]"""

        user_prompt = f"""Based on the following papers the user has recently marked as interested, extract the key research themes:

{papers_text}

Provide 5-10 themes that capture the user's main research interests."""

        try:
            response = self.llm_client.chat_with_system(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                temperature=0.7,
            )

            # Parse JSON response
            themes_json = response.strip()
            if themes_json.startswith("```"):
                themes_json = themes_json.split("```")[1]
                if themes_json.startswith("json"):
                    themes_json = themes_json[4:]

            themes = json.loads(themes_json)

            if not isinstance(themes, list):
                raise ValueError("LLM response is not a list")

            # Validate themes
            themes = [t for t in themes if isinstance(t, str) and len(t.strip()) > 0]

            if not themes:
                raise ValueError("No valid themes in LLM response")

            # Save themes to database
            new_themes = []
            for theme in themes[:10]:  # Limit to 10 themes
                interest_theme = InterestTheme(
                    user_id=1,
                    theme=theme.strip(),
                    source_papers=json.dumps(interested_paper_ids),
                    is_active=True,
                )
                self.session.add(interest_theme)
                new_themes.append(interest_theme)

            self.session.commit()
            logger.info(f"Generated and saved {len(new_themes)} interest themes: {themes}")

            return new_themes

        except Exception as e:
            logger.error(f"Failed to generate themes with LLM: {e}")
            self.session.rollback()
            return []
